{"ast":null,"code":"import _classCallCheck from \"/Users/gakumar/Desktop/charts-private/ChRIS_ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/gakumar/Desktop/charts-private/ChRIS_ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _ from \"lodash\"; // Builds the webcola tree chart\n\n// Description: Parse Data from IPluginItem and convert to a ITreeChart\n\n/*\n* Params: items = Pass the items array of nodes\n* rootNodeId = Root node id which indicates the root id\n*/\nvar TreeModel =\n/*#__PURE__*/\nfunction () {\n  function TreeModel(items, rootNodeId) {\n    _classCallCheck(this, TreeModel);\n\n    this.treeChart = void 0;\n    this._workingIndex = 0;\n    this._workingId = 0;\n    this._workingItems = [];\n    this._nodes = [];\n    this._links = [];\n    this._totalRows = 0;\n    this.treeChart = {\n      nodes: [],\n      links: [],\n      totalRows: 0\n    };\n    this.parseFeedTreeData(items, rootNodeId);\n  }\n\n  _createClass(TreeModel, [{\n    key: \"parseFeedTreeData\",\n    value: function parseFeedTreeData(items, rootNodeId) {\n      // Note: Reverse the array to expedite parsing also for demo purposes\n      this._workingItems = items.reverse().slice();\n\n      this._parseRootNode(items, rootNodeId);\n\n      this._parseTreeChildren(this._workingItems, this._workingId); // Set the treeChart objects:\n\n\n      this._setNodes(this._nodes);\n\n      this._setLinks(this._links);\n\n      this.treeChart.totalRows = this._totalRows;\n      return this.treeChart;\n    } // Working props for parsing\n\n  }, {\n    key: \"_parseRootNode\",\n    // Counts the Max number of vertical nodes (for calculating height dynamically)\n    // Description: Find the root of this tree:\n    value: function _parseRootNode(items, rootNodeId) {\n      var parentItem = _.find(items, function (item) {\n        return item.previous_id === rootNodeId;\n      });\n\n      if (!!parentItem) {\n        this._nodes.push({\n          item: parentItem,\n          index: this._workingIndex,\n          isRoot: true\n        });\n\n        this._workingItems = this._removeWorkingItem(parentItem);\n        this._workingId = parentItem.id;\n        this._workingIndex++;\n      } // Note: this is not the root or leaf plugin so increment the total rows\n\n\n      this._totalRows++;\n    } // Description: Recursive method to build tree\n\n  }, {\n    key: \"_parseTreeChildren\",\n    value: function _parseTreeChildren(workingItems, _workingId) {\n      var _this = this;\n\n      var _parentIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var cloneArr = workingItems.slice();\n      cloneArr.forEach(function (item) {\n        if (item.previous_id === _workingId) {\n          var index = _this._workingIndex; // is this a child to the node we are working on?\n\n          _this._nodes.push({\n            item: item,\n            index: index\n          });\n\n          _this._links.push({\n            target: _this._workingIndex,\n            source: _parentIndex,\n            value: 1\n          });\n\n          _this._workingItems = _this._removeWorkingItem(item);\n          _this._workingIndex++;\n\n          _this._findChildrenNodes(item.id, index);\n        }\n      });\n      workingItems.length > 0 && this._totalRows++; // Increment total rows for counting vertical levels\n    } // Description: Find children to this node\n\n  }, {\n    key: \"_findChildrenNodes\",\n    value: function _findChildrenNodes(id, _parentIndex) {\n      var workingChildrenArr = _.filter(this._workingItems, function (subitem) {\n        return id === subitem.previous_id;\n      }); // Does this node have children - recur\n\n\n      !!workingChildrenArr && workingChildrenArr.length > 0 && this._parseTreeChildren(workingChildrenArr, id, _parentIndex);\n    } // Description: Remove item from working array\n\n  }, {\n    key: \"_removeWorkingItem\",\n    value: function _removeWorkingItem(item) {\n      var arr = _.filter(this._workingItems, function (subitem) {\n        return item.id !== subitem.id;\n      });\n\n      return arr;\n    } // Set the treeChart nodes array\n\n  }, {\n    key: \"_setNodes\",\n    value: function _setNodes(nodes) {\n      this.treeChart.nodes = nodes;\n    } // Set the treeChart links array\n\n  }, {\n    key: \"_setLinks\",\n    value: function _setLinks(links) {\n      this.treeChart.links = links;\n    }\n  }]);\n\n  return TreeModel;\n}();\n\nexport { TreeModel as default };","map":{"version":3,"sources":["/Users/gakumar/Desktop/charts-private/ChRIS_ui/src/api/models/tree.model.ts"],"names":["_","TreeModel","items","rootNodeId","treeChart","_workingIndex","_workingId","_workingItems","_nodes","_links","_totalRows","nodes","links","totalRows","parseFeedTreeData","reverse","slice","_parseRootNode","_parseTreeChildren","_setNodes","_setLinks","parentItem","find","item","previous_id","push","index","isRoot","_removeWorkingItem","id","workingItems","_parentIndex","cloneArr","forEach","target","source","value","_findChildrenNodes","length","workingChildrenArr","filter","subitem","arr"],"mappings":"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","sourcesContent":["import * as cola from \"webcola\";\nimport { IPluginItem } from \"./pluginInstance.model\";\nimport { NodeId, INode } from \"./tree-node.model\";\nimport _ from \"lodash\";\n\n// Builds the webcola tree chart\nexport interface ITreeChart {\n  nodes: INode[];\n  links: ILink[];\n  constraints?: IConstraint[];\n  totalRows: number;\n}\n\nexport interface IConstraint {\n  axis: string;\n  left: number;\n  right: number;\n  gap: number;\n}\n\nexport interface ILink {\n  target: number;\n  source: number;\n  value: number;\n}\n\n\n\n// Description: Parse Data from IPluginItem and convert to a ITreeChart\n/*\n* Params: items = Pass the items array of nodes\n* rootNodeId = Root node id which indicates the root id\n*/\n\nexport default class TreeModel {\n  treeChart: ITreeChart;\n  constructor(items: IPluginItem[], rootNodeId?: NodeId) {\n    this.treeChart = {\n      nodes: [],\n      links: [],\n      totalRows: 0\n    };\n    this.parseFeedTreeData(items, rootNodeId);\n  }\n\n  parseFeedTreeData(items: IPluginItem[], rootNodeId?: NodeId): ITreeChart {\n    // Note: Reverse the array to expedite parsing also for demo purposes\n    this._workingItems = items.reverse().slice();\n    this._parseRootNode(items, rootNodeId);\n    this._parseTreeChildren(this._workingItems, this._workingId);\n\n    // Set the treeChart objects:\n    this._setNodes(this._nodes);\n    this._setLinks(this._links);\n    this.treeChart.totalRows = this._totalRows;\n    return this.treeChart;\n  }\n\n  // Working props for parsing\n  private _workingIndex: number = 0;\n  private _workingId: NodeId = 0;\n  private _workingItems: IPluginItem[] = [];\n  private _nodes: INode[] = [];\n  private _links: ILink[] = [];\n  private  _totalRows = 0; // Counts the Max number of vertical nodes (for calculating height dynamically)\n  // Description: Find the root of this tree:\n  private _parseRootNode(items: IPluginItem[], rootNodeId: NodeId) {\n    const parentItem = _.find(items, (item: IPluginItem) => {\n      return item.previous_id === rootNodeId;\n    });\n\n    if (!!parentItem) {\n      this._nodes.push({\n        item: parentItem,\n        index: this._workingIndex,\n        isRoot: true\n      });\n      this._workingItems = this._removeWorkingItem(parentItem);\n      this._workingId = parentItem.id;\n      this._workingIndex++;\n    }\n    // Note: this is not the root or leaf plugin so increment the total rows\n    this._totalRows++;\n  }\n\n\n  // Description: Recursive method to build tree\n  private _parseTreeChildren(\n    workingItems: IPluginItem[],\n    _workingId: NodeId,\n    _parentIndex: number = 0\n  ) {\n    const cloneArr: IPluginItem[] = workingItems.slice();\n    cloneArr.forEach((item: IPluginItem) => {\n      if (item.previous_id === _workingId) {\n        const index = this._workingIndex;\n        // is this a child to the node we are working on?\n        this._nodes.push({\n          item,\n          index\n        });\n        this._links.push({\n          target: this._workingIndex,\n          source: _parentIndex,\n          value: 1\n        });\n        this._workingItems = this._removeWorkingItem(item);\n        this._workingIndex++;\n        this._findChildrenNodes(item.id, index);\n      }\n    });\n    (workingItems.length > 0) && this._totalRows++; // Increment total rows for counting vertical levels\n  }\n\n\n  // Description: Find children to this node\n  private _findChildrenNodes(id: NodeId, _parentIndex: number) {\n    const workingChildrenArr = _.filter(\n      this._workingItems,\n      (subitem: IPluginItem) => {\n        return id === subitem.previous_id;\n      }\n    );\n    // Does this node have children - recur\n    !!workingChildrenArr &&  workingChildrenArr.length > 0 &&\n      this._parseTreeChildren(workingChildrenArr, id, _parentIndex);\n  }\n\n\n  // Description: Remove item from working array\n  private _removeWorkingItem(item: IPluginItem): IPluginItem[] {\n    const arr = _.filter(this._workingItems, (subitem: IPluginItem) => {\n      return item.id !== subitem.id;\n    });\n    return arr;\n  }\n\n  // Set the treeChart nodes array\n  private _setNodes(nodes: INode[]) {\n    this.treeChart.nodes = nodes;\n  }\n\n  // Set the treeChart links array\n  private _setLinks(links: ILink[]) {\n    this.treeChart.links = links;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}